#define _GNU_SOURCE

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

#define error(msg, ...) error_imp("(error \"" msg "\")", ##__VA_ARGS__)

static char *formaterrorstring = "(error \"cannot format error message\")";

static char *error_imp(char *msg, ...)
{
	char *err = NULL;
	va_list args;

	va_start(args, msg);
	if (vasprintf(&err, msg, args) < 0)
		return NULL;
	va_end(args);

	return err;
}

struct token
{
	struct token *next;
	char *s;
};

static struct token formaterrortoken3 = { NULL, ")" };
static struct token formaterrortoken2 = { &formaterrortoken3, NULL };
static struct token formaterrortoken1 = { &formaterrortoken2, "error" };
static struct token formaterrortoken0 = { &formaterrortoken1, "(" };

static void free_tokens(struct token *tokens)
{
	struct token *next;

	if (tokens == &formaterrortoken0)
		return;

	while (tokens)
	{
		next = tokens->next;
		free(tokens->s);
		free(tokens);
		tokens = next;
	}
}

static struct token *formaterrortoken(char *msg)
{
	formaterrortoken2.s = msg;
	return &formaterrortoken0;
}

static struct token *append_token(struct token *tokens, struct token ***tail, char *s, char *e)
{
	struct token *token;

	token = malloc(sizeof(struct token));
	if (!token)
	{
		**tail = NULL;
		free_tokens(tokens);
		return formaterrortoken("cannot allocate token");
	}

	token->s = strndup(s, e - s);
	token->next = NULL;

	if (!token->s)
	{
		**tail = NULL;
		free_tokens(token);
		free_tokens(tokens);
		return formaterrortoken("cannot format token");
	}

	**tail = token;
	*tail = &token->next;

	return NULL;
}

static struct token *parse(char *code)
{
	struct token *tokens = NULL;
	struct token **tail = &tokens;
	struct token *err = NULL;
	char *p = code;

	while (*p && !err)
	{
		char *start;

		while (*p && *p == ' ')
			p++;
		start = p;

		while (*p && *p != ' ')
			p++;

		err = append_token(tokens, &tail, start, p);
	}

	return tokens;
}

static char *pr_str(struct token *ast)
{
};

static struct token *READ(char *code)
{
	struct token *ast = parse(code);
	free(code);
	return ast;
}

static struct token *EVAL(struct token *ast)
{
	return ast;
}

static char *PRINT(struct token *ast)
{
	return pr_str(ast);
}

static char *rep(char *code)
{
	return PRINT(EVAL(READ(code)));
}

static char *prompt(void)
{
	char *line = NULL;
	size_t cap = 0;
	size_t len = 0;
	int c;

	printf("user> ");

	c = fgetc(stdin);
	if (c == EOF)
		return NULL;

	while (c != EOF)
	{
		if (len + 1 > cap)
		{
			char *prevline;
			cap = cap > 0 ? 2 * cap : 1;
			line = realloc(prevline = line, cap);
			if (!line && cap)
			{
				free(prevline);
				return error("cannot allocate input line buffer");
			}
		}

		if (c == '\n' || c == '\r' || c == '\0')
		{
			line[len++] = '\0';
			c = EOF;
		}
		else
		{
			line[len++] = c;
			c = fgetc(stdin);
		}

	}

	return line;
}

int main(int argc, char **argv)
{
	char *line;

	do
	{
		line = prompt();
		if (line)
		{
			char *result = rep(line);
			if (result && strlen(result))
				printf("%s\n", result);
			free(result);
		}
	} while (line != NULL);

	printf("\n");
}
