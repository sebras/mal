#define _GNU_SOURCE

#include <readline/readline.h>
#include <readline/history.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>
#include <string.h>
#include <stdarg.h>

static var_imp(void *var)
{
}

#define var(x) var_imp((void *)&(x))

#define throw(ctx) \
	{ \
		errno += 2; \
		longjmp(jmpbuf, 1); \
	}

#define try(ctx) \
        { \
		jmp_buf jmpbuf; \
		errno = 0; \
		if (setjmp(jmpbuf) == 0) do \

#define always(ctx) \
			while (0); \
		} \
		if (errno < 3) { \
			errno++; \
			do \

#define catch(ctx) \
                        while (0); \
		} \
        } \
	if (errno > 1)

#define error(msg, ...) error_imp("(error \"" msg "\")", ##__VA_ARGS__)

static char *formaterrorstring = "(error \"cannot format error message\")";

static char *error_imp(char *msg, ...)
{
	char *err = NULL;
	va_list args;

	va_start(args, msg);
	if (vasprintf(&err, msg, args) < 0)
		return NULL;
	va_end(args);

	return err;
}

struct token
{
	struct token *next;
	char *s;
};

static struct token formaterrortoken3 = { NULL, ")" };
static struct token formaterrortoken2 = { &formaterrortoken3, NULL };
static struct token formaterrortoken1 = { &formaterrortoken2, "error" };
static struct token formaterrortoken0 = { &formaterrortoken1, "(" };

static void free_tokens(struct token *tokens)
{
	struct token *next;

	if (tokens == &formaterrortoken0)
		return;

	while (tokens)
	{
		next = tokens->next;
		free(tokens->s);
		free(tokens);
		tokens = next;
	}
}

#define formaterrortoken(msg) formaterrortoken_imp("\"" msg "\"")

static struct token *formaterrortoken_imp(char *msg)
{
	formaterrortoken2.s = msg;
	return &formaterrortoken0;
}

static struct token *append_token(struct token *tokens, struct token ***tail, char *s, char *e)
{
	struct token *token;

	token = malloc(sizeof(struct token));
	if (!token)
	{
		**tail = NULL;
		free_tokens(tokens);
		return formaterrortoken("cannot allocate token");
	}

	token->s = strndup(s, e - s);
	token->next = NULL;

	if (!token->s)
	{
		**tail = NULL;
		free_tokens(token);
		free_tokens(tokens);
		return formaterrortoken("cannot format token");
	}

	**tail = token;
	*tail = &token->next;

	return NULL;
}

#define WHITESPACE "\t\n\v\f\r "
#define COMMA ","
#define SPLICEUNQOTE "~@"
#define SPECIAL "[]{}()'`~^@"
#define QUOTE '"'
#define ESCAPEDQUOTE "\\\""
#define SEMICOLON ';'
#define NONSYMBOLCHARS WHITESPACE "[]{}()'\"`,;"

static struct token *tokenize(char *code)
{
	struct token *tokens = NULL;
	struct token **tail = &tokens;
	char *e = code + strlen(code);
	char *p = code;

	while (p < e)
	{
		struct token *err = NULL;

		while (p < e && strchr(WHITESPACE COMMA, *p))
			p++;

		if (e - p >= 2 && !strcmp(SPLICEUNQOTE, p))
		{
			err = append_token(tokens, &tail, p, p + 2);
			p += 2;
		}
		else if (e - p >= 1 && strchr(SPECIAL, *p))
		{
			err = append_token(tokens, &tail, p, p + 1);
			p++;
		}
		else if (e - p >= 1 && *p == QUOTE)
		{
			char *start = p++;
			char *s;

			while (p < e && *p != QUOTE)
			{
				if (!strncmp(p, ESCAPEDQUOTE, 2))
					p += 2;
				else if (*p != QUOTE)
					p++;
			}

			if (p == e)
			{
				free_tokens(tokens);
				return formaterrortoken("unterminated string encountered");
			}

			if (p < e && *p != QUOTE)
			{
				free_tokens(tokens);
				return formaterrortoken("string not terminated by quote");
			}

			p++;

			start = s = strndup(start, p - start);

			while (*s)
			{
				if (*s == '\\')
				{
					if (strlen(s) <= 1)
					{
						free_tokens(tokens);
						return formaterrortoken("unterminated string escape sequence");
					}

					switch (s[1])
					{
					case 'a': *s = '\a'; break;
					case 'b': *s = '\b'; break;
					case 'e': *s = '\x1b'; break;
					case 'f': *s = '\f'; break;
					case 'n': *s = '\n'; break;
					case 'r': *s = '\r'; break;
					case 't': *s = '\t'; break;
					case 'v': *s = '\v'; break;
					case '\\': *s = '\\'; break;
					case '"': *s = '"'; break;
					default:
						free_tokens(tokens);
						return formaterrortoken("invalid string escape sequence");
					}
					memmove(&s[1], &s[2], strlen(s));
				}

				s++;
			}

			err = append_token(tokens, &tail, start, s);

			free(start);
		}
		else if (e - p >= 1 && *p == SEMICOLON)
			p = e;
		else if (e - p >= 1)
		{
			char *start = p++;

			while (p < e && !strchr(NONSYMBOLCHARS, *p))
				p++;
			err = append_token(tokens, &tail, start, p);
		}

		if (err)
			return err;
	}

	return tokens;
}

struct node
{
	enum
	{
		ERROR = -1,
		FALSE = 0,
		TRUE = 1,
		NIL,
		INTEGER,
		REAL,
		SYMBOL,
		STRING,
		LIST,
	} type;
	struct node *down, *next;
	union {
		char *error;
		long long integer;
		double real;
		char *string;
		char *symbol;
	} u;
};

struct node parseerror;

static struct node *new_error(char *msg)
{
	parseerror.type = ERROR;
	parseerror.u.error = msg;
	return &parseerror;
}

static void free_node(struct node *node)
{
	struct node *next;

	if (node == &parseerror)
		return;

	while (node)
	{
		next = node->next;
		if (node->type == LIST)
			free_node(node->down);

		switch (node->type)
		{
		case SYMBOL:
			free(node->u.symbol);
			break;
		}
		free(node);

		node = next;
	}
}

static struct node *new_node(int type)
{
	struct node *node = malloc(sizeof(struct node));
	if (!node)
		return new_error("error allocating node");
	node->next = NULL;
	node->down = NULL;
	node->type = type;
	return node;
}

static struct node *new_nil(void)
{
	return new_node(NIL);
}

static struct node *new_true(void)
{
	return new_node(TRUE);
}

static struct node *new_false(void)
{
	return new_node(FALSE);
}

static struct node *new_integer(long long integer)
{
	struct node *node = new_node(INTEGER);
	if (node->type == INTEGER)
		node->u.integer = integer;
	return node;
}

static struct node *new_real(double real)
{
	struct node *node = new_node(REAL);
	if (node->type == REAL)
		node->u.real = real;
	return node;
}

static struct node *new_string(char *string)
{
	struct node *node = new_node(STRING);
	if (node->type == STRING)
	{
		node->u.string = strndup(&string[1], strlen(string) - 2);
		if (!node->u.string)
		{
			free_node(node);
			return new_error("error allocating node string");
		}
	}
	return node;
}

static struct node *new_symbol(char *symbol)
{
	struct node *node = new_node(SYMBOL);
	if (node->type == SYMBOL)
	{
		node->u.symbol = strdup(symbol);
		if (!node->u.symbol)
		{
			free_node(node);
			return new_error("error allocating node symbol");
		}
	}
	return node;
}

static struct node *new_list(struct node *down)
{
	struct node *node = new_node(LIST);
	if (node->type == LIST)
		node->down = down;
	return node;
}

static int is_integer(char *s)
{
	char *end = NULL;

	errno = 0;
	(void) strtod(s, &end);
	if (errno == ERANGE)
		return 0;

	if (end && *end != '\0')
		return 0;

	return 1;
}

static int is_real(char *s)
{
	char *end = NULL;

	errno = 0;
	(void) strtod(s, &end);
	if (errno == ERANGE)
		return 0;

	if (end && *end != '\0')
		return 0;

	return 1;
}

static struct node *read_atom(struct token **tokens)
{
	struct node *node;
	char *s = (*tokens)->s;

	if (!strcmp(s, "nil"))
		node = new_nil();
	else if (!strcmp(s, "true"))
		node = new_true();
	else if (!strcmp(s, "false"))
		node = new_false();
	else if (is_integer(s))
		node = new_integer(strtoll(s, NULL, 0));
	else if (is_real(s))
		node = new_real(strtod(s, NULL));
	else if (*s == '"')
		node = new_string(s);
	else
		node = new_symbol(s);

	if (node->type != ERROR)
		*tokens = (*tokens)->next;

	return node;
}

static struct node *read_form(struct token **tokens);

static struct node *read_list(struct token **tokens)
{
	struct token *token = *tokens;
	struct node *last = NULL;
	struct node *down = NULL;

	while (token && strcmp(token->s, ")"))
	{
		struct node *next = read_form(&token);

		if (next->type == ERROR)
		{
			free_node(down);
			return next;
		}

		if (last)
			last->next = next;
		else
			down = next;
		last = next;
	}

	if (!token || strcmp(token->s, ")"))
	{
		free_node(down);
		return new_error("unterminated list");
	}

	*tokens = token->next;

	return new_list(down);
}

static struct node *read_form(struct token **tokens)
{
	struct node *ast = NULL;
	struct node *node = NULL;
	struct node *last = NULL;

	if (!strcmp((*tokens)->s, "("))
	{
		*tokens = (*tokens)->next;
		node = read_list(tokens);
	}
	else
		node = read_atom(tokens);

	return node;
}

static struct node *read_str(char *code)
{
	struct token *tokens = tokenize(code);
	struct node *node = read_form(&tokens);
	free_tokens(tokens);
	return node;
}

static char *pr_list(struct node *node, int readable);

static char *pr_str(struct node *node, int readable)
{
	char *result;

	if (!node)
		return NULL;

	switch (node->type)
	{
	case ERROR:
		if (asprintf(&result, "Error: %s", node->u.error) < 0)
			result = strdup("Error: cannot format error message");
		break;
	case FALSE: result = strdup("false"); break;
	case TRUE: result = strdup("true"); break;
	case NIL: result = strdup("nil"); break;
	case INTEGER:
		if (asprintf(&result, "%lld", node->u.integer) < 0)
			result = strdup("Error: cannot format integer");
		break;
	case REAL:
		if (asprintf(&result, "%f", node->u.integer) < 0)
			result = strdup("Error: cannot format real");
		break;
	case SYMBOL:
		result = strdup(node->u.symbol);
		break;
	case STRING:
		if (asprintf(&result, "\"%s\"", node->u.string) < 0)
			result = strdup("Error: cannot format string");
		break;
	case LIST:
		result = pr_list(node->down, readable);
		break;
	}

	return result;
}

static char *pr_list(struct node *node, int readable)
{
	char *prevresult, *result = NULL;
	char *part;
	char *p;
	int new, rem, used, cap = 0;

	result = malloc(2);
	if (!result)
		return strdup("cannot format result");
	strcpy(result, "(");

	while (node)
	{
		used = strlen(result);

		part = pr_str(node, readable);

		new = snprintf(NULL, 0, "%s%s", part, node->next ? " " : "");
		if (new < 0)
		{
			free(result);
			free(part);
			return strdup("cannot format result");
		}

		if (used + new + 1 >= cap)
		{
			while (used + new + 1 >= cap)
				cap = cap > 0 ? 2 * cap : 1;

			result = realloc(prevresult = result, cap);
			if (!result)
			{
				free(prevresult);
				free(part);
				return strdup("cannot extend result");
			}
			if (prevresult == NULL)
				*result = '\0';
		}

		p = result + used;
		rem = cap - used;

		new = snprintf(p, rem, "%s%s", part, node->next ? " " : "");
		if (new < 0)
		{
			free(result);
			free(part);
			return strdup("cannot format result");
		}

		free(part);
		node = node->next;
	}

	used = strlen(result);

	if (used + 2 + 1 >= cap)
	{
		while (used + 2 + 1 >= cap)
			cap = cap > 0 ? 2 * cap : 1;

		result = realloc(prevresult = result, cap);
		if (!result)
		{
			free(prevresult);
			free(part);
			return strdup("cannot extend result");
		}
		if (prevresult == NULL)
			*result = '\0';
	}

	strcat(result, ")");

	return result;
}

static struct node *READ(char *code)
{
	struct node *ast = read_str(code);
	free(code);
	return ast;
}

static struct node *EVAL(struct node *ast)
{
	return ast;
}

static char *PRINT(struct node *ast)
{
	char *result = pr_str(ast, 1);
	free_node(ast);
	return result;
}

static char *rep(char *code)
{
	return PRINT(EVAL(READ(code)));
}

int main(int argc, char **argv)
{
	char *line, *result;

	do
	{
		line = readline("user> ");
		if (line)
			add_history(line);

		if (line)
		{
			result = rep(line);
			if (strlen(reslut))
				print("%s\n", result);
		}
		else
			result = NULL;

		free(result);

	} while (line != NULL);

	printf("\n");
}
